package stream

import "sort"

//type mapfunc[S, T any] func(S)T

//type Stream[E any] interface {
//	Filter(func(e E) bool) Stream[E]
//	OrElse(e E) Stream[E]
//	First(func(e E) bool) E
//}

func Of[E any](elems []E) *stream[E] {
	return &stream[E]{
		eles: elems,
	}
}


type stream[E any] struct {
	eles []E
	def  E
}

func (s *stream[E]) OrElse(e E) *stream[E] {
	s.def = e
	return s
}

func (s *stream[E]) Filter(m match[E]) *stream[E] {
	res := make([]E, 0, len(s.eles))
	for i, e := range s.eles {
		if m(e) {
			res = append(res, s.eles[i])
		}
	}

	return Of[E](res)
}

//func (s *stream[E]) Map(m mapFunc[E, T])  {

//}

// Distinct return the slice that contains unique element
func (s *stream[E]) Distinct(c comparator[E]) *stream[E] {
	res := make([]E, 0, len(s.eles))
	// TODO optimize
	for i := 0; i < len(s.eles); i++ {
		found := false
		for j := i + 1; j < len(s.eles); j++ {
			if c(s.eles[i], s.eles[j]) == 0 {
				found = true
			}
		}
		if !found {
			res = append(res, s.eles[i])
		}
	}
	return Of[E](res)
}

// Sort stable sort
func (s *stream[E]) Sort(c comparator[E]) *stream[E] {
	sort.SliceStable(s.eles, func(i, j int) bool {
		return c(s.eles[i], s.eles[j]) < 0
	})
	return s
}

func (s *stream[E]) Limit(offset int, limit int) *stream[E] {
	res := make([]E, 0, len(s.eles))
	for i := range s.eles {
		if i >= offset && len(res) <= limit {
			res = append(res, s.eles[i])
		}
	}
	return Of[E](res)
}

func (s *stream[E]) Skip(num int) *stream[E] {
	res := make([]E, 0, len(s.eles))
	for i := range s.eles {
		if i >= num {
			res = append(res, s.eles[i])
		}
	}

	return Of[E](res)
}

func (s *stream[E]) ForEach(f func(e E)) *stream[E] {
	for i := range s.eles {
		f(s.eles[i])
	}
	return s
}

func (s *stream[E]) ToSlice() []E {
	return s.eles
}

func (s *stream[E]) Max(c comparator[E]) E {
	panic("implement me")
}

func (s *stream[E]) Min(c comparator[E]) E {
	panic("implement me")
}

func (s *stream[E]) AnyMatch(m match[E]) bool {
	for _, e := range s.eles {
		if m(e) {
			return true
		}
	}
	return false
}

func (s *stream[E]) AllMatch(m match[E]) bool {
	for _, e := range s.eles {
		if !m(e) {
			return false
		}
	}
	return true
}

func (s *stream[E]) NoneMatch(m match[E]) bool {
	for _, e := range s.eles {
		if m(e) {
			return false
		}
	}
	return true
}

func (s *stream[E]) Count() int {
	return len(s.eles)
}

func (s *stream[E]) FindFirst(m match[E]) E {
	for _, e := range s.eles {
		if m(e) {
			return e
		}
	}
	return s.def
}

func (s *stream[E]) FindLast(m match[E]) E {
	res := make([]E, 0, len(s.eles))
	for _, e := range s.eles {
		if m(e) {
			res = append(res, e)
		}
	}

	if len(res) == 0 {
		return  s.def
	}

	return res[len(res)- 1]
}

func (s *stream[E]) FindAny(m match[E]) E {
	for _, e := range s.eles {
		if m(e) {
			return e
		}
	}
	return s.def
}

func (s *stream[E]) FindNth(m match[E]) E {
	panic("implement me")
}

func (s *stream[E]) Concat(tail *stream[E]) *stream[E] {
	res := make([]E, 0)
	res = append(s.eles, tail.eles...)
	return  Of[E](res)
}

type match[E any] func(e E) bool

type comparator[E any] func(e1, e2 E) int

type mapFunc[S any, T any] func()