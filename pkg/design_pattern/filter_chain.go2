package design_pattern

import "errors"

//type Request interface {
//	Value(key string)
//}
//
//type RpcRequest interface {
//	Request
//	ServiceName() string
//}
//
//type RpcFilter[R RpcRequest] func(req R)
//
//type Filter[R Request] func(req R)
//
//type RpcFilter[R RpcRequest] func(req R)
//
//func DubboFilter(req DubboRpcRequest) {
//}
//
//var _ Filter[DubboRpcRequest] = DubboFilter
//var _ RpcFilter[DubboRpcRequest] = DubboFilter
//
//
//
//
//type Chain[R Request] func(next Filter[R]) Filter[R]
//
//type FilterChainBuilder[R Request] struct {
//	chains []Chain[R]
//}
//
//func (f FilterChainBuilder[R]) Add(chain Chain[R]){
//	f.chains = append(f.chains, chain)
//}
//
//func (f *FilterChainBuilder[R]) Root() Filter[R] {
//	root := f.chains[0](nil)
//	for i := 1; i < len(f.chains); i++ {
//		root = f.chains[i](root)
//	}
//	return root
//}
//
//
//type HttpRequest struct {
//
//}
//
//func (h *HttpRequest) Value(key string) {
//	panic("implement me")
//}
//
//
//
//type DubboRpcRequest struct {
//
//}
//
//func (d DubboRpcRequest) Value(key string) {
//	panic("implement me")
//}
//
//func (d DubboRpcRequest) ServiceName() string {
//	panic("implement me")
//}



type Container struct {
	m map[string]interface{}
}

func (c *Container) Get[T any](key string) (T, error){
	val, ok := m[key]
	if ok {
		return val.(T), nil
	}
	var t T
	return t, errors.New("not found")
}



